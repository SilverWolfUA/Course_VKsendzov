Создать ssh-ключ:
ssh-keygen -t rsa -C "github_account"


!!!ПЕРВОНАЧАЛЬНАЯ НАСТРОЙКА!!!
Имя пользователя:
git config --global user.name "name"
e-mail пользователя:
git config --global user.email "email"
Включить подсветку:
git config --global color.ui auto
Установить редактор:
git config --global core.editor "редактор/путь"
Установить имя <имя_ветки> для вашей ветки по умолчанию:
git config --global init.defaultBranch <имя_ветки>
Список настройки конфигурации:
git config --list


!!!СОЗДАНИЕ РЕПОЗИТОРИЯ!!!
Проинициализировать репозиторий в текущей папке:
git init <имя_проекта>
Клонирует проект с удаленного репозитория:
git clone <url> <папка>
Добавить удалённый репозиторий и присвоить ему имя <имя_репо>:
git remote add <имя_репо> <url>


!!!ОПЕРАЦИИ С ФАЙЛАМИ!!!
Удаляет конкретный файл из рабочей директории и индексирует его удаление:
git rm <имя_файла>
Убирает конкретный файл из контроля версий, но физически оставляет его на своём месте:
git rm --cached <имя_файла>:
Принудительное удаление:
git rm -f <имя_файла>
Перемещает и переименовывает указанный файл, сразу индексируя его для последующего коммита:
git mv <имя_файла> <новое_имя>


!!!ИГНОРИРОВАНИЕ НЕКОТОРЫХ ФАЙЛОВ!!!
С помощью файла .gitignore
https://github.com/github/gitignore
https://www.toptal.com/developers/gitignore


!!!ВНЕСЕНИЕ ИЗМЕНЕНИЙ!!!
Перечисляет все новые или изменённые файлы, которые нуждаются в фиксации:
git status

Проиндексировать файл для последующего коммита:
git add <имя_файла>
Проиндексировать все файлы:
git add .

Показывает различия по внесённым изменениям в ещё не проиндексированных файлах:
git diff
ППоказывает различия между проиндексированной и последней зафиксированной версиями файлов:
git diff --cached или git diff --staged


!!!ОТКАТ КОММИТОВ!!!
Отменить изменения, перенося ссылку на ветку назад, на более старый коммит:
- для локальных репозиторий или это обновление вашей ветви, перемещение HEAD для добавления или удаления коммитов из ветви. Эта операция изменяет историю фиксации(коммита). 
git reset <хеш_коммита или имя_файла>
Сбрасывает всю историю вместе с состоянием рабочей директории до указанного коммита:
git reset --hard <имя_коммита>
- для удаленных репозиторий или  это создание нового коммита, который отменяет изменения, внесенные другими коммитами
git revert <хеш_коммита>
Сброс состояния файла на указаное
git restore <имя_файла> 
git restore --staged <имя_файла>


!!!COMMIT!!!
Сохранить изменения в коммит с сообщением:
git commit -m 'комментарий'
с автоматической индексацией:
git commit -a -m 'комментарий'


!!!ПРОСМОТР ИСТОРИИ!!!
Посмотреть историю коммитов:
git log
git log --oneline       (короткая запись)
git log --oneline --all (на всех ветках)
История изменений конкретного файла, включая его переименование
git log --follow <имя_файла>
Показывает разницу между содержанием коммитов двух веток:
git diff <первая_ветка>...<вторая_ветка>
Выводит информацию и показывает изменения в выбранном коммите:
git show <имя_коммита>
Посмотреть историю всех действий во время работы в репозитории:
git reflog



!!!REPO!!!
Просмотреть список настроенных удалённых репозиториев:
git remote
Просмотреть адреса для чтения и записи, привязанные к репозиторию:
git remote -v
Получить данные из удалённых репозиторий:
git fetch <имя_репо>
Получить изменения из удалённой ветки и слить их со своей текущей:
git pull
git pull --rebase

Отправить на удаленный репозиторий:
git push
git push <имя_репо> <имя_ветки>
Принудительно перезаписать удаленную ветку на текущую:
git push --forse     ,(после git rebase или сложных операций)


!!!BRANCH!!!
Показать список веток:
git branch
Создать новую ветку:
git branch <имя_ветки>
Создать и перейти на ветку <имя_ветки>:
git checkout -b <имя_ветки>  или git switch -c <имя_ветки>
Перейти на последний коммит в ветке:
git checkout <имя_ветки> или git switch <имя_ветки>

Переименовать имя ветки:
git branch --move <старое_имя_ветки> <новое_имя_ветки>  или 
git branch -m <старое_имя_ветки> <новое_имя_ветки>
Создать, переименовать имя ветки на удаленном репозитории:
git push --set-upstream <имя_репо> <новое_имя_ветки>  или
git push -u <имя_репо> <новое_имя_ветки>

Удалить ветку на локальном репозитории:
git branch -d <имя_ветки>
Удалить ветку на удаленном репозитории:
git push --delete <имя_репо>  <старое_имя_ветки> или
git push -d <имя_репо> <старое_имя_ветки>

Выполнить слияние ветки:
git merge <имя_сливаемой_ветки>

Смена базовой ветки (сдвинуть точку старта ветки)
git rebase <имя_ветки_с_какой_будет_обьединение>

Переместить указатель на нужный коммит
git branch -f <имя_ветки> HEAD~n, где n - число коммитов
 или
git branch -f <имя_ветки> <хеш_коммита>

!!!TAG!!!
Посмотреть теги:
git tag --list
Добавить Тег:
git teg <версия>
Добавить на удаленный репозиторий:
git push --tags
Удалить тег:
git tag -d <версия>
Удалить тег из удаленного репозитория:
git push --delete <имя_репо> <версия>


---СЛОЖНЫЕ ОПЕРАЦИИ---
!!!СОХРАНЕНИЕ ФРАГМЕНТОВ!!!
Временно сохраняет все незафиксированные изменения отслеживаемых файлов:
git stash
Выводит список всех временных сохранений:
git stash list
Добавить файл в stash:
git stash push <имя_файла>
Восстанавливает состояние ранее сохранённых версий файлов:
git stash pop <HEAD>
Сбрасывает последние временно сохранённыe изменения:
git stash drop

Склеить коммиты:
git rebase -i HEAD~n, где n - число коммитов
Перенос изменений через squash:
git merge <имя_ветки> --squash

Копировать несколько коммитов на место, где сейчас находишься (HEAD) или текущую ветку:
git cherry-pick <коммит1> <коммит2>
Перенести последний коммит ветки:
git cherry-pick <имя_ветки> 
Перенести все коммиты с ветки:
git cherry-pick ..<имя_ветки> 

Изменить последний коммит:
git commit --amend

!!!КОНФЛИКТЫ!!!
Отменить merge:
git merge --abort

!!!RENAME & DELETE REPO!!!
Переименование удалённого репозитория:
git remote rename <старое_имя_репо> <новое_имя_репо>
Удаление удалённого репозитория:
git remote remove <имя_репо>
 или
git remote rm <имя_репо>
